#include<stdio.h>
#include<malloc.h>
typedef struct macierz
{
    int wiersze,kolumny;
    float* wartosci;
}macierz;

macierz* utworz_macierz(macierz* nowa,int wiersze, int kolumny,int wypelnij,float tab[]){
    macierz* nowa_macierz = (macierz*)(malloc(sizeof(macierz)));

    nowa_macierz->wiersze = wiersze;
    nowa_macierz->kolumny = kolumny;
    nowa_macierz->wartosci = (float*)(calloc(wiersze * kolumny,sizeof(float*)));

    if(wypelnij == 1)
    {
        for(int i = 0; i < wiersze * kolumny; i++)
        {
        nowa_macierz->wartosci[i] = tab[i];
        }
    }
    
    else
    {
        for(int i = 0; i < wiersze * kolumny; i++)
        {
            nowa_macierz->wartosci[i] = 0;
        }
    }
    
    return nowa_macierz;
    }
macierz* dopelniajaca(macierz* wejscie,int wiersz, int kolumna)
{
    macierz* temp = utworz_macierz(temp,wejscie->wiersze - 1, wejscie->kolumny - 1,0,0);
    int k = 0;
    for(int i = 0; i < wejscie->wiersze; i++)
    {
        for(int j = 0;j < wejscie->kolumny; j++)
        {
            if(i != wiersz && j != kolumna)
            {
                temp->wartosci[k] = wejscie->wartosci[i* wejscie->kolumny + j];
                k++;
            }
        }
    }
    return temp;
}
float liczenie_wyznacznika(macierz* wejscie,float wyznacznik)
{
    if(wejscie->wiersze == wejscie->kolumny)
    {
        if(wejscie->wiersze > 1)
        {
            for(int i = 0;i < wejscie->kolumny;i++)
            {
                if(i % 2 == 0)
                {
                wyznacznik = wyznacznik + wejscie->wartosci[i] * liczenie_wyznacznika(dopelniajaca(wejscie ,0 ,i), 0);
                }
                else
                {
                wyznacznik = wyznacznik - wejscie->wartosci[i] * liczenie_wyznacznika(dopelniajaca(wejscie ,0 ,i ), 0);
                }
                
            }
        }
    
        else
            {
                return wejscie->wartosci[0];
            }
        return wyznacznik;
    }

    else
    {
        printf("Z wymiarów nie wynika policzenie wyznacznika :)");
    }
}
macierz* mnozenie(macierz* pierwsza,macierz* druga)
{
    if(pierwsza->kolumny == druga->wiersze)
    {
        macierz* wynik = utworz_macierz(wynik,pierwsza->wiersze, druga->kolumny,0,0);
            for(int i = 0;i < pierwsza->wiersze; i++)
            {
                for(int j = 0;j < druga->kolumny;j++)
                {
                    for(int k = 0;k < pierwsza->kolumny;k++)
                    {
                        wynik->wartosci[i * wynik->kolumny + j] = wynik->wartosci[i * wynik->kolumny + j] + pierwsza->wartosci[pierwsza->kolumny * i + k] * druga->wartosci[druga->kolumny * k + j];
                    }
                    printf("%.0f ",wynik->wartosci[i * wynik->kolumny + j]);
                }
                printf("\n");
            }
            return wynik;
    }
    else
    {
        printf("drugiej wiersze równe pierwszej kolumny, zrób to a z mnożenia będziesz będziesz dumny");
    }
    
}
macierz* transponowana(macierz* wejscie)
{
    macierz* trans = utworz_macierz(trans,wejscie->wiersze,wejscie->kolumny,0,0);
    for(int i = 0;i < wejscie->wiersze;i++)
    {
        for(int j = 0;j < wejscie->kolumny;j++)
        {
            trans->wartosci[i * wejscie->kolumny + j] = wejscie->wartosci[j * wejscie->kolumny + i];
        }
    }
    return trans;
} 
macierz* odwrotna(macierz* wejscie)
{
    macierz* odwrotna = utworz_macierz(odwrotna,wejscie->wiersze, wejscie->kolumny,0,0);
    for(int i = 0;i < wejscie->kolumny;i++)
    {
        for(int j = 0;j < wejscie->wiersze;j++)
        {
            if((i * wejscie->wiersze + j) % 2 == 0)
            {
                odwrotna->wartosci[i * wejscie->kolumny + j] =  liczenie_wyznacznika(dopelniajaca(wejscie,i,j),0)/liczenie_wyznacznika(wejscie,0);
            }
            else
            {
                odwrotna->wartosci[i * wejscie->kolumny + j] = - liczenie_wyznacznika(dopelniajaca(wejscie,i,j),0)/liczenie_wyznacznika(wejscie,0);
            }
            
        }
    }
    return transponowana(odwrotna);
}
float rzad(macierz* wejscie)
{
    if(liczenie_wyznacznika(wejscie,0) != 0)
    {
        return wejscie->kolumny;
    }
    else
    {
        for(int i = 0;i < wejscie->kolumny;i++)
        {
            for(int j = 0;j < wejscie->wiersze;j++)
            {
                rzad(dopelniajaca(wejscie,i,j));
            }
        }
    }    
}
int main()
{
    float tab1[] = {
    1,2,3,4,5,6,7,8,
    4,2,12,1341,124,124,124,43,
    7,8,3,4,5,4,3,6,
    1,22,3,423,255,6,7,8,
    1,24,3,54,5,6,7,8,
    1,4,2,5,7,2,4,6,
    54,23,6,8,2,13,4,4,
    12,53,2,3,1,1,3,1
    };
    float tab2[] = {
    1,2,3,
    4,5,6,
    7,8,9};
    macierz* pierwsza = utworz_macierz(pierwsza,8,8,1,tab1);
    macierz* druga = utworz_macierz(druga,3,3,1,tab2);
    //for(int i=0;i < 9; i++)
        //printf("%0.f\n",dopelniajaca(pierwsza,2,2)->wartosci[i]);
    //mnozenie(pierwsza,odwrotna(pierwsza));
    printf("%.0f",rzad(druga));
    //printf("wyznacznik = %.0f\n",liczenie_wyznacznika(pierwsza,0));
    //transponowana(pierwsza);
    //for(int i = 0; i < 9 ; i++)
        //printf("%.0f\n",pierwsza->wartosci);

}
